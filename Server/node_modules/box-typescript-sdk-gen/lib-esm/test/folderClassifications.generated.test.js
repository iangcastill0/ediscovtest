"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.client = void 0;
exports.getOrCreateSecondClassification = getOrCreateSecondClassification;
const classifications_generated_js_1 = require("../managers/classifications.generated.js");
const folderClassifications_generated_js_1 = require("../managers/folderClassifications.generated.js");
const utils_js_1 = require("../internal/utils.js");
const commons_generated_js_1 = require("./commons.generated.js");
const commons_generated_js_2 = require("./commons.generated.js");
const commons_generated_js_3 = require("./commons.generated.js");
const commons_generated_js_4 = require("./commons.generated.js");
const classificationTemplate_generated_js_1 = require("../schemas/classificationTemplate.generated.js");
exports.client = (0, commons_generated_js_1.getDefaultClient)();
async function getOrCreateSecondClassification(classificationTemplateInput) {
    const classificationTemplate = new classificationTemplate_generated_js_1.ClassificationTemplate({
        id: classificationTemplateInput.id,
        type: classificationTemplateInput.type,
        scope: classificationTemplateInput.scope,
        templateKey: classificationTemplateInput.templateKey,
        displayName: classificationTemplateInput.displayName,
        hidden: classificationTemplateInput.hidden,
        copyInstanceOnItemCopy: classificationTemplateInput.copyInstanceOnItemCopy,
        fields: classificationTemplateInput.fields,
    });
    const classifications = classificationTemplate.fields[0].options;
    const currentNumberOfClassifications = classifications.length;
    if (currentNumberOfClassifications == 1) {
        const classificationTemplateWithNewClassification = await exports.client.classifications.addClassification([
            new classifications_generated_js_1.AddClassificationRequestBody({
                data: {
                    key: (0, utils_js_1.getUuid)(),
                    staticConfig: {
                        classification: {
                            colorId: 4,
                            classificationDefinition: 'Other description',
                        },
                    },
                },
            }),
        ]);
        return classificationTemplateWithNewClassification.fields[0].options[1];
    }
    return classifications[1];
}
test('testFolderClassifications', async function testFolderClassifications() {
    const classificationTemplate = await (0, commons_generated_js_3.getOrCreateClassificationTemplate)();
    const classification = await (0, commons_generated_js_4.getOrCreateClassification)(classificationTemplate);
    const folder = await (0, commons_generated_js_2.createNewFolder)();
    await expect(async () => {
        await exports.client.folderClassifications.getClassificationOnFolder(folder.id);
    }).rejects.toThrow();
    const createdFolderClassification = await exports.client.folderClassifications.addClassificationToFolder(folder.id, {
        requestBody: {
            boxSecurityClassificationKey: classification.key,
        },
    });
    if (!(createdFolderClassification.boxSecurityClassificationKey ==
        classification.key)) {
        throw new Error('Assertion failed');
    }
    const folderClassification = await exports.client.folderClassifications.getClassificationOnFolder(folder.id);
    if (!(folderClassification.boxSecurityClassificationKey == classification.key)) {
        throw new Error('Assertion failed');
    }
    const secondClassification = await getOrCreateSecondClassification(classificationTemplate);
    const updatedFolderClassification = await exports.client.folderClassifications.updateClassificationOnFolder(folder.id, [
        new folderClassifications_generated_js_1.UpdateClassificationOnFolderRequestBody({
            value: secondClassification.key,
        }),
    ]);
    if (!(updatedFolderClassification.boxSecurityClassificationKey ==
        secondClassification.key)) {
        throw new Error('Assertion failed');
    }
    await exports.client.folderClassifications.deleteClassificationFromFolder(folder.id);
    await expect(async () => {
        await exports.client.folderClassifications.getClassificationOnFolder(folder.id);
    }).rejects.toThrow();
    await exports.client.folders.deleteFolderById(folder.id);
});
//# sourceMappingURL=folderClassifications.generated.test.js.map